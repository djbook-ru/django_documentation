# Russian translations for Django package.
# Copyright (C) Django Software Foundation and contributors
# This file is distributed under the same license as the Django package.
# Automatically generated <>, 2012, 2013.
# Dmitriy Kostochko <alerion.um@gmail.com>, 2013, 2014, 2015.
#
msgid ""
msgstr ""
"Project-Id-Version: Django 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-03-19 15:06+0200\n"
"PO-Revision-Date: 2015-06-05 16:28+0300\n"
"Last-Translator: Dmitriy Kostochko <alerion.um@gmail.com>\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Gtranslator 2.91.6\n"

# 649d32f81a064b32986e8b43eb7595ab
#: ../../ref/models/instances.txt:3
msgid "Model instance reference"
msgstr "Объект модели"

# c6efd924e01f4f5e85840f18f35c7521
#: ../../ref/models/instances.txt:7
msgid ""
"This document describes the details of the ``Model`` API. It builds on the "
"material presented in the :doc:`model </topics/db/models>` and :doc:"
"`database query </topics/db/queries>` guides, so you'll probably want to "
"read and understand those documents before reading this one."
msgstr ""
"Этот раздел описывает ``Model`` API. Изложенный материал опирается на "
"материал, изложенный в разделах о :doc:`моделях </topics/db/models>` и :doc:"
"`выполнении запросов </topics/db/queries>`, возможно вам следует прочитать "
"их перед прочтением этого раздела."

# 9e05c32aecc046e7ab0539d8b19518ec
#: ../../ref/models/instances.txt:12
msgid ""
"Throughout this reference we'll use the :ref:`example Weblog models "
"<queryset-model-example>` presented in the :doc:`database query guide </"
"topics/db/queries>`."
msgstr ""
"В примерах будут использованы :ref:` примеры моделей web-блога <queryset-"
"model-example>` представленные в разделе о :doc:`выполнении запросов </"
"topics/db/queries>`."

# 0c1451ca4f1545dbbb555d1be14cfe78
#: ../../ref/models/instances.txt:17
msgid "Creating objects"
msgstr "Создание объектов"

# 35323d643346474b90514a3432055e40
#: ../../ref/models/instances.txt:19
msgid ""
"To create a new instance of a model, just instantiate it like any other "
"Python class:"
msgstr ""
"Чтобы создать объект модели, просто создайте ее экземпляр как любого другого "
"класса Python:"

# 23fe6764d1174f5897dac08572e9dc9b
#: ../../ref/models/instances.txt:24
msgid ""
"The keyword arguments are simply the names of the fields you've defined on "
"your model. Note that instantiating a model in no way touches your database; "
"for that, you need to :meth:`~Model.save()`."
msgstr ""
"Именованные аргументы -- это названия полей определенных в модели. Создание "
"экземпляра модели не выполняет никаких запросов к базе данных; для "
"сохранения вызовите метод :meth:`~Model.save()`."

# fdf8a912a25143dba9bda386a47eb2d3
#: ../../ref/models/instances.txt:30
msgid ""
"You may be tempted to customize the model by overriding the ``__init__`` "
"method. If you do so, however, take care not to change the calling signature "
"as any change may prevent the model instance from being saved. Rather than "
"overriding ``__init__``, try using one of these approaches:"
msgstr ""
"Возможно, вам захочется переопределить метод ``__init__``. В таком случае не "
"переопределяйте сигнатуру вызова этого метода, иначе объект модели может не "
"сохраняться. Вместо переопределения ``__init__`` лучше используйте один из "
"следующих подходов:"

# e484785c269c4b5480bea184149e8068
#: ../../ref/models/instances.txt:35
msgid "Add a classmethod on the model class::"
msgstr "Добавить метод класса в модель::"

# 9212d78f8f2346a48ec444903a7425f0
#: ../../ref/models/instances.txt:50
msgid "Add a method on a custom manager (usually preferred)::"
msgstr "Добавить метод в менеджер модели(лучший вариант)::"

#: ../../ref/models/instances.txt:66
msgid "Customizing model loading"
msgstr "Настройка загрузки модели"

#: ../../ref/models/instances.txt:72
msgid ""
"The ``from_db()`` method can be used to customize model instance creation "
"when loading from the database."
msgstr ""
"Метод ``from_db()`` позволяет настроить создания экземпляра модели при "
"загрузке данных из базы данных."

#: ../../ref/models/instances.txt:75
msgid ""
"The ``db`` argument contains the database alias for the database the model "
"is loaded from, ``field_names`` contains the names of all loaded fields, and "
"``values`` contains the loaded values for each field in ``field_names``. The "
"``field_names`` are in the same order as the ``values``, so it is possible "
"to use ``cls(**(zip(field_names, values)))`` to instantiate the object. If "
"all of the model's fields are present, then ``values`` are guaranteed to be "
"in the order ``__init__()`` expects them. That is, the instance can be "
"created by ``cls(*values)``. It is possible to check if all fields are "
"present by consulting ``cls._deferred`` - if ``False``, then all fields have "
"been loaded from the database."
msgstr ""
"Аргумент ``db`` содержит название базы данных, из которой загружается "
"объект, ``field_names`` содержит список загруженных полей, а ``values`` "
"содержит значения полей из ``field_names``. Поля в ``field_names`` "
"расположены в таком же порядке как и ``values``, поэтому можно использовать "
"``cls(**(zip(field_names, values)))`` для создания объекта. Если все поля "
"модели присутствуют, порядок значений в ``values`` будет таким, каким их "
"ожидает ``__init__()``. И вы можете создать объект с помощью "
"``cls(*values)``. Все поля модели загружены, если ``cls._deferred`` равен "
"``False``."

#: ../../ref/models/instances.txt:86
msgid ""
"In addition to creating the new model, the ``from_db()`` method must set the "
"``adding`` and ``db`` flags in the new instance's ``_state`` attribute."
msgstr ""
"Кроме создания экземпляра модели метод ``from_db()`` должен установить флаги "
"``adding`` и ``db`` атрибута ``_state`` нового объекта модели."

#: ../../ref/models/instances.txt:89
msgid ""
"Below is an example showing how to record the initial values of fields that "
"are loaded from the database::"
msgstr ""
"В этом примере вы можете увидеть как сохранить начальные загруженные "
"значений полей и проверять их при сохранении::"

#: ../../ref/models/instances.txt:115
msgid ""
"The example above shows a full ``from_db()`` implementation to clarify how "
"that is done. In this case it would of course be possible to just use "
"``super()`` call in the ``from_db()`` method."
msgstr ""
"Это оригинальная реализация метода ``from_db()``, чтобы показать как он "
"работает. На самом деле мы бы могли просто вызвать родительский метод через "
"``super()``."

#: ../../ref/models/instances.txt:120
msgid "Refreshing objects from database"
msgstr "Обновление объектов из базы данных"

#: ../../ref/models/instances.txt:126
msgid ""
"If you need to reload a model's values from the database, you can use the "
"``refresh_from_db()`` method. When this method is called without arguments "
"the following is done:"
msgstr ""
"Если вам необходимо обновить значения модели из базы данных, вы можете "
"использовать ``refresh_from_db()``. Если вызвать этот метод без аргументов, "
"произойдет следующее:"

#: ../../ref/models/instances.txt:130
msgid ""
"All non-deferred fields of the model are updated to the values currently "
"present in the database."
msgstr "Все загруженные поля модели будут обновлены значениями из базы данных."

#: ../../ref/models/instances.txt:132
msgid ""
"The previously loaded related instances for which the relation's value is no "
"longer valid are removed from the reloaded instance. For example, if you "
"have a foreign key from the reloaded instance to another model with name "
"``Author``, then if ``obj.author_id != obj.author.id``, ``obj.author`` will "
"be thrown away, and when next accessed it will be reloaded with the value of "
"``obj.author_id``."
msgstr ""
"Если ранее загруженные внешние связи уже не верны, они будут удалены. "
"Например, если объект содержит внешнюю связь на модель ``Author``, и ``obj."
"author_id != obj.author.id``, ``obj.author`` будет очищен и при следующем "
"обращении будет загружен объект со значением ``obj.author_id``."

#: ../../ref/models/instances.txt:139
msgid ""
"Note that only fields of the model are reloaded from the database. Other "
"database dependent values such as annotations are not reloaded."
msgstr ""
"Обратите внимание, загружаются только поля модели. Аннотации и прочие "
"специфические значения не будут загружены."

#: ../../ref/models/instances.txt:142
msgid ""
"The reloading happens from the database the instance was loaded from, or "
"from the default database if the instance wasn't loaded from the database. "
"The ``using`` argument can be used to force the database used for reloading."
msgstr ""
"Перезагрузка выполняется из базы данных, из которой объект был изначально "
"загружен, или из базы данных по умолчанию, если база данных не была явно "
"указана. Аргумент ``using`` позволяет явно указать базу данных."

#: ../../ref/models/instances.txt:146
msgid ""
"It is possible to force the set of fields to be loaded by using the "
"``fields`` argument."
msgstr "Вы можете указать какие поля загружать с помощью аргумента ``fields``."

#: ../../ref/models/instances.txt:149
msgid ""
"For example, to test that an ``update()`` call resulted in the expected "
"update, you could write a test similar to this::"
msgstr ""
"Например, чтобы проверить вызов метода ``update()``, вы можете использовать "
"следующий тест::"

#: ../../ref/models/instances.txt:161
msgid ""
"Note that when deferred fields are accessed, the loading of the deferred "
"field's value happens through this method. Thus it is possible to customize "
"the way deferred loading happens. The example below shows how one can reload "
"all of the instance's fields when a deferred field is reloaded::"
msgstr ""
"Обратите внимание, при доступе к отложенным(deferred) полям они загружаются "
"этим методом. Таким образом вы можете переопределить способ загрузки "
"отложенных полей. В этом примере мы перегружаем все поля, если загружаются "
"отложенные поля::"

#: ../../ref/models/instances.txt:183
msgid ""
"A helper method that returns a set containing the attribute names of all "
"those fields that are currently deferred for this model."
msgstr "Возвращает список текущих отложенных полей для экземпляра модели."

# a1af197f5374441fbd6f668e42644aef
#: ../../ref/models/instances.txt:189
msgid "Validating objects"
msgstr "Проверка объектов"

# 93bd9a6303ac44f981b1dcbe691d5c83
#: ../../ref/models/instances.txt:191
msgid "There are three steps involved in validating a model:"
msgstr "Проверка объектов модели проходив в три этапа:"

# 2d28ada844a04da99aff382e3cec5dcd
#: ../../ref/models/instances.txt:193
msgid "Validate the model fields - :meth:`Model.clean_fields()`"
msgstr "Проверка полей модели - :meth:`Model.clean_fields()`"

# 5960436d670c49339e1f8a77a898d12f
#: ../../ref/models/instances.txt:194
msgid "Validate the model as a whole - :meth:`Model.clean()`"
msgstr "Проверка всего объекта - :meth:`Model.clean()`"

# d3c5d873719c4115a6ed637da6a6642b
#: ../../ref/models/instances.txt:195
msgid "Validate the field uniqueness - :meth:`Model.validate_unique()`"
msgstr "Проверка уникальности полей - :meth:`Model.validate_unique()`"

# c04c6f856f3f42c9af2f08d69dce7d7b
#: ../../ref/models/instances.txt:197
msgid ""
"All three steps are performed when you call a model's :meth:`~Model."
"full_clean()` method."
msgstr ""
"Все три этапа выполняются при вызове метода :meth:`~Model.full_clean()`."

# 0ef0de90d1694bd6a19ea26ae8fa0ac2
#: ../../ref/models/instances.txt:200
msgid ""
"When you use a :class:`~django.forms.ModelForm`, the call to :meth:`~django."
"forms.Form.is_valid()` will perform these validation steps for all the "
"fields that are included on the form. See the :doc:`ModelForm documentation "
"</topics/forms/modelforms>` for more information. You should only need to "
"call a model's :meth:`~Model.full_clean()` method if you plan to handle "
"validation errors yourself, or if you have excluded fields from the :class:"
"`~django.forms.ModelForm` that require validation."
msgstr ""
"При использовании :class:`~django.forms.ModelForm`, вызов :meth:`~django."
"forms.Form.is_valid()` выполняет проверку для всех полей, включенных в "
"форму. Подробности смотрите :doc:`раздел о ModelForm </topics/forms/"
"modelforms>`. Вы должны использовать метод :meth:`~Model.full_clean()` "
"модели только если собираетесь самостоятельно обрабатывать ошибки "
"валидности, или если :class:`~django.forms.ModelForm` не содержит поля, "
"которые должны проверяться."

# 06e39a0d61cf4fd8b83b5cea1435e0a3
#: ../../ref/models/instances.txt:210
msgid ""
"This method calls :meth:`Model.clean_fields()`, :meth:`Model.clean()`, and :"
"meth:`Model.validate_unique()` (if ``validate_unique`` is ``True``), in that "
"order and raises a :exc:`~django.core.exceptions.ValidationError` that has a "
"``message_dict`` attribute containing errors from all three stages."
msgstr ""
"Этот метод вызывает :meth:`Model.clean_fields()`, :meth:`Model.clean()`, и :"
"meth:`Model.validate_unique()`(если ``validate_unique`` равно ``True``) в "
"указанном порядке и вызывает исключение :exc:`~django.core.exceptions."
"ValidationError`, которое содержит атрибут ``message_dict`` с ошибками всех "
"трех этапов проверки."

# 63d338c2a66e4453b34aad181339d1a7
#: ../../ref/models/instances.txt:215
msgid ""
"The optional ``exclude`` argument can be used to provide a list of field "
"names that can be excluded from validation and cleaning. :class:`~django."
"forms.ModelForm` uses this argument to exclude fields that aren't present on "
"your form from being validated since any errors raised could not be "
"corrected by the user."
msgstr ""
"Необязательный аргумент ``exclude`` используется, чтобы исключить часть "
"полей из проверки. :class:`~django.forms.ModelForm` использует этот аргумент "
"для полей не включенных в форму, так как ошибки для этих полей не могут быть "
"исправлены пользователем."

# e1a3dcc242d3470fad26fa9bd9828a0d
#: ../../ref/models/instances.txt:221
msgid ""
"Note that ``full_clean()`` will *not* be called automatically when you call "
"your model's :meth:`~Model.save()` method. You'll need to call it manually "
"when you want to run one-step model validation for your own manually created "
"models. For example::"
msgstr ""
"Обратите внимание, ``full_clean()`` *не* вызывается при вызове метода :meth:"
"`~Model.save()`. Если вы хотите выполнить проверку для созданных вами "
"объектов модели, вам необходимо явно вызывать этот метод. Например::"

# 6c596143cc8a410eadd412441a29c35c
#: ../../ref/models/instances.txt:234
msgid ""
"The first step ``full_clean()`` performs is to clean each individual field."
msgstr "Первым делом ``full_clean()`` выполняет проверку каждого поля."

# 59bc3b15bd0246f58c315b3ace31c220
#: ../../ref/models/instances.txt:238
msgid ""
"This method will validate all fields on your model. The optional ``exclude`` "
"argument lets you provide a list of field names to exclude from validation. "
"It will raise a :exc:`~django.core.exceptions.ValidationError` if any fields "
"fail validation."
msgstr ""
"Этот метод проверяет все поля модели. Необязательный аргумент ``exclude`` "
"используется, чтобы исключить часть полей из проверки. Если одно из полей не "
"пройдет проверку, будет вызвано исключение :exc:`~django.core.exceptions."
"ValidationError`."

# 5a68808ab9ab4bf5a61145be54c1134a
#: ../../ref/models/instances.txt:243
msgid ""
"The second step ``full_clean()`` performs is to call :meth:`Model.clean()`. "
"This method should be overridden to perform custom validation on your model."
msgstr ""
"Следующим этапов проверки в ``full_clean()`` будет вызов метода :meth:`Model."
"clean()`. Этот метод должен быть переопределен, если вам нужна "
"дополнительная проверка модели."

# 84b3e98dac6644bfae1c75bb3ba03ba5
#: ../../ref/models/instances.txt:248
msgid ""
"This method should be used to provide custom model validation, and to modify "
"attributes on your model if desired. For instance, you could use it to "
"automatically provide a value for a field, or to do validation that requires "
"access to more than a single field::"
msgstr ""
"Этот метод должен быть переопределен, если вам нужна дополнительная проверка "
"модели или изменить значения атрибутов. Для объектов, вы можете определить "
"его для автоматического определения полей, или для проверки, которая требует "
"значения нескольких полей::"

# 020bd77fc6b447a88c362544893c4a1e
#: ../../ref/models/instances.txt:267
msgid ""
"Note, however, that like :meth:`Model.full_clean()`, a model's ``clean()`` "
"method is not invoked when you call your model's :meth:`~Model.save()` "
"method."
msgstr ""
"Обратите внимание, :meth:`Model.full_clean()`, как и метод модели "
"``clean()``, не вызываются при вызове :meth:`~Model.save()`."

# add054fa6fe04f13bc58b99020a5edab
#: ../../ref/models/instances.txt:270
msgid ""
"In the above example, the :exc:`~django.core.exceptions.ValidationError` "
"exception raised by ``Model.clean()`` was instantiated with a string, so it "
"will be stored in a special error dictionary key, :data:`~django.core."
"exceptions.NON_FIELD_ERRORS`. This key is used for errors that are tied to "
"the entire model instead of to a specific field::"
msgstr ""
"Любое исключение :exc:`~django.core.exceptions.ValidationError` вызванное в "
"``Model.clean()`` будет сохранено со специальным ключом в словаре ошибок, :"
"data:`~django.core.exceptions.NON_FIELD_ERRORS`, который используется для "
"ошибок относящихся ко всей модели, а не конкретному полю::"

#: ../../ref/models/instances.txt:282
msgid ""
"To assign exceptions to a specific field, instantiate the :exc:`~django.core."
"exceptions.ValidationError` with a dictionary, where the keys are the field "
"names. We could update the previous example to assign the error to the "
"``pub_date`` field::"
msgstr ""
"Чтобы добавить ошибку валидации к определенному полю, создайте экземпляр :"
"exc:`~django.core.exceptions.ValidationError` со словарем, где ключи "
"отображают необходимые поля. Добавим к предыдущему примеру проверку поля "
"``pub_date``::"

# 91c9d98f74c54c40a03252a75f9e3ca8
#: ../../ref/models/instances.txt:295
msgid ""
"Finally, ``full_clean()`` will check any unique constraints on your model."
msgstr "Также ``full_clean()`` выполняет все проверки на уникальность модели."

# 50104e825b5444d783baf3fa5ac928c7
#: ../../ref/models/instances.txt:299
msgid ""
"This method is similar to :meth:`~Model.clean_fields`, but validates all "
"uniqueness constraints on your model instead of individual field values. The "
"optional ``exclude`` argument allows you to provide a list of field names to "
"exclude from validation. It will raise a :exc:`~django.core.exceptions."
"ValidationError` if any fields fail validation."
msgstr ""
"Этот метод похож на :meth:`~Model.clean_fields`, но проверяет уникальность "
"полей, используя все определенные правила, а не значения полей."
"Необязательный аргумент ``exclude`` используется, чтобы исключить часть "
"полей из проверки. Вызывает исключение :exc:`~django.core.exceptions."
"ValidationError`, если поле не прошло проверку."

# 03268cec819643c6b67a15565ec4818b
#: ../../ref/models/instances.txt:305
msgid ""
"Note that if you provide an ``exclude`` argument to ``validate_unique()``, "
"any :attr:`~django.db.models.Options.unique_together` constraint involving "
"one of the fields you provided will not be checked."
msgstr ""
"Заметим, при использовании аргумента ``exclude``, все правила определенные "
"в :attr:`~django.db.models.Options.unique_together`, включающие одно из "
"указанных полей, не будет учитываться при проверке."

# 098c3d147234461bad39df3e02a35830
#: ../../ref/models/instances.txt:311
msgid "Saving objects"
msgstr "Сохранение объектов"

# c840ed2fcba34cca99fd1acd27a82263
#: ../../ref/models/instances.txt:313
msgid "To save an object back to the database, call ``save()``:"
msgstr "Чтобы сохранить объект в базе данных, используйте ``save()``:"

# 5ba36080b7ba4d20994326616e1ef50d
#: ../../ref/models/instances.txt:317
msgid ""
"If you want customized saving behavior, you can override this ``save()`` "
"method. See :ref:`overriding-model-methods` for more details."
msgstr ""
"Если вы хотите изменить процесс сохранения, переопределите метод ``save()``. "
"Подробности в разделе :ref:`overriding-model-methods`."

# c52b843201a2476fa312ed7b6bf111ec
#: ../../ref/models/instances.txt:320
msgid ""
"The model save process also has some subtleties; see the sections below."
msgstr "Процесс сохранения модели имеет ряд особенностей описанных ниже."

# f774cc85cd73454bb517c9844e7254d3
#: ../../ref/models/instances.txt:323
msgid "Auto-incrementing primary keys"
msgstr "Автоинкрементные первичные ключи"

# 40ea6476c815472688ba7fbbcfc19fa5
#: ../../ref/models/instances.txt:325
msgid ""
"If a model has an :class:`~django.db.models.AutoField` — an auto-"
"incrementing primary key — then that auto-incremented value will be "
"calculated and saved as an attribute on your object the first time you call "
"``save()``::"
msgstr ""
"Если модель содержит :class:`~django.db.models.AutoField` — автоинкрементный "
"первичный ключи — его значение будет вычислено и сохранено в атрибут объекта "
"при первом вызове метода ``save()``::"

# 651b53b421564ed38375f6909679f70e
#: ../../ref/models/instances.txt:334
msgid ""
"There's no way to tell what the value of an ID will be before you call "
"``save()``, because that value is calculated by your database, not by Django."
msgstr ""
"Нельзя точно сказать каким будет значение ID до вызова метода ``save()``, "
"так как оно вычисляется базой данных, а не Django."

# 9b83a66be2014246a4a2c59d1d6f957e
#: ../../ref/models/instances.txt:337
msgid ""
"For convenience, each model has an :class:`~django.db.models.AutoField` "
"named ``id`` by default unless you explicitly specify ``primary_key=True`` "
"on a field in your model. See the documentation for :class:`~django.db."
"models.AutoField` for more details."
msgstr ""
"Для удобства каждая модель содержит полей :class:`~django.db.models."
"AutoField` с названием ``id``, если вы не указали параметр "
"``primary_key=True`` для поля модели. Подробности в описании :class:`~django."
"db.models.AutoField`."

# 190326b03b374f859182598c91a12f37
#: ../../ref/models/instances.txt:343
msgid "The ``pk`` property"
msgstr "Свойство ``pk``"

# f539c4204852435a95e3b12a1412b519
#: ../../ref/models/instances.txt:347
msgid ""
"Regardless of whether you define a primary key field yourself, or let Django "
"supply one for you, each model will have a property called ``pk``. It "
"behaves like a normal attribute on the model, but is actually an alias for "
"whichever attribute is the primary key field for the model. You can read and "
"set this value, just as you would for any other attribute, and it will "
"update the correct field in the model."
msgstr ""
"Независимо от того, определили вы первичный ключ самостоятельно, или "
"позволили Django добавить его, каждая модель содержит свойство ``pk``. Он "
"ведет себя как обычный атрибут, но на самом деле является псевдонимом для "
"атрибута первичного ключа. Вы можете получить или установить его значение, "
"так же как и любого другого атрибута, при этом будет обновлено "
"соответствующее поле модели."

# 206bfe2281e3478ba50e6cd99f458b05
#: ../../ref/models/instances.txt:355
msgid "Explicitly specifying auto-primary-key values"
msgstr "Явное определение значения первичного ключа"

# daf5d25b018a4eb58a7907f4d0f07994
#: ../../ref/models/instances.txt:357
msgid ""
"If a model has an :class:`~django.db.models.AutoField` but you want to "
"define a new object's ID explicitly when saving, just define it explicitly "
"before saving, rather than relying on the auto-assignment of the ID::"
msgstr ""
"Если модель содержит :class:`~django.db.models.AutoField` но вы хотите явно "
"указать значение ID нового объекта при сохранении, просто укажите его::"

# 3a93a98526b8426ab9497a2aac2905f2
#: ../../ref/models/instances.txt:366
msgid ""
"If you assign auto-primary-key values manually, make sure not to use an "
"already-existing primary-key value! If you create a new object with an "
"explicit primary-key value that already exists in the database, Django will "
"assume you're changing the existing record rather than creating a new one."
msgstr ""
"Если вы определяете значение первичного автоинкрементного ключа, убедитесь "
"что это значение не существует уже в базе данных! Если вы укажите "
"существующее в базе значение, Django предположит что вы хотите изменить "
"запись в базе данных, а не сохранить новую."

# 35bff39e62734d489e22b1fa14ae38f8
#: ../../ref/models/instances.txt:371
msgid ""
"Given the above ``'Cheddar Talk'`` blog example, this example would override "
"the previous record in the database::"
msgstr ""
"Учитывая пример с блогом ``'Cheddar Talk'`` выше, этот код перезапишет "
"предыдущий объект в базе данных::"

# 819cafcb27af459785fec1a2a0eae827
#: ../../ref/models/instances.txt:377
msgid ""
"See `How Django knows to UPDATE vs. INSERT`_, below, for the reason this "
"happens."
msgstr ""
"О том, как это определяется, смотрите :ref:`How Django knows to UPDATE vs. "
"INSERT` (FIXME) ниже."

# 5be5ef59904444f9821b174edb1dbdc0
#: ../../ref/models/instances.txt:380
msgid ""
"Explicitly specifying auto-primary-key values is mostly useful for bulk-"
"saving objects, when you're confident you won't have primary-key collision."
msgstr ""
"Явное определение первичного ключа в основном полезно при сохранении "
"множества объектов, когда вы уверенны что все значения уникальны."

# d04372d78ad4406aa992d39972fe9a8f
#: ../../ref/models/instances.txt:384
msgid "What happens when you save?"
msgstr "Что происходит при сохранении?"

# fc8ca633e516453ea0ed02cb05bd78b1
#: ../../ref/models/instances.txt:386
msgid "When you save an object, Django performs the following steps:"
msgstr "При сохранении объекта Django выполняет следующие шаги:"

# 49a649847dc940979b384aa452c71120
#: ../../ref/models/instances.txt:388
msgid ""
"**Emit a pre-save signal.** The :doc:`signal </ref/signals>` :attr:`django."
"db.models.signals.pre_save` is sent, allowing any functions listening for "
"that signal to take some customized action."
msgstr ""
"**Посылается сигнал pre-save.** Посылается сигнал :attr:`django.db.models."
"signals.pre_save`, позволяя функциям, обрабатывающим этот сигнал, выполнить "
"какие-либо действия."

# 40caa366c585447dafced6ad65484e31
#: ../../ref/models/instances.txt:393
msgid ""
"**Pre-process the data.** Each field on the object is asked to perform any "
"automated data modification that the field may need to perform."
msgstr ""
"**Предварительная обработка данных.** Каждое поле объекта выполняет "
"изменения значения поля при необходимости."

# bedb769fff8148bc9f47e76ac72d11c2
#: ../../ref/models/instances.txt:397
msgid ""
"Most fields do *no* pre-processing — the field data is kept as-is. Pre-"
"processing is only used on fields that have special behavior.  For example, "
"if your model has a :class:`~django.db.models.DateField` with "
"``auto_now=True``, the pre-save phase will alter the data in the object to "
"ensure that the date field contains the current date stamp. (Our "
"documentation doesn't yet include a list of all the fields with this "
"\"special behavior.\")"
msgstr ""
"Большинство полей *не* выполняют предварительную обработку данных — значение "
"полей сохраняется как оно есть. Она выполняется для полей с особым "
"поведением. Например, если ваша модель содержит поле :class:`~django.db."
"models.DateField` с ``auto_now=True``, на этапе предварительной обработки "
"значение поля будет установлено в текущую дату. (Наша документация пока не "
"содержит список полей с \"особым поведением\".)"

# a69652b8dc60447a952cccd013446ab8
#: ../../ref/models/instances.txt:405
msgid ""
"**Prepare the data for the database.** Each field is asked to provide its "
"current value in a data type that can be written to the database."
msgstr ""
"**Подготовка данных для базы данных.** Каждое поле преобразует текущее "
"значение к типу данных, которой может быть сохранен в базу данных."

# e82d742cedf142fc98ede65b66888951
#: ../../ref/models/instances.txt:408
msgid ""
"Most fields require *no* data preparation. Simple data types, such as "
"integers and strings, are 'ready to write' as a Python object. However, more "
"complex data types often require some modification."
msgstr ""
"Большинство полей *не* требует подготовки данных. Простые типы данных, такие "
"как числа и строки, уже 'готовы к сохранению' как объекты Python. Однако, "
"большинство сложных типов данных требуют некоторой модификации."

# e03d498e9b2240698a9d9927cea8db6b
#: ../../ref/models/instances.txt:412
msgid ""
"For example, :class:`~django.db.models.DateField` fields use a Python "
"``datetime`` object to store data. Databases don't store ``datetime`` "
"objects, so the field value must be converted into an ISO-compliant date "
"string for insertion into the database."
msgstr ""
"Например, поле :class:`~django.db.models.DateField` использует объект Python "
"``datetime`` для хранения значения. База данных не принимает объект "
"``datetime``, поэтому значение поля должно быть преобразовано в строковое "
"представление даты в соответствии стандарту ISO перед сохранением в базу "
"данных."

# 91daa17ee949449ab037d99f75483d64
#: ../../ref/models/instances.txt:417
msgid ""
"**Insert the data into the database.** The pre-processed, prepared data is "
"then composed into an SQL statement for insertion into the database."
msgstr ""
"**Сохранение данных в базе данных.** Предварительно обработанные, "
"подготовленные данные формируются в SQL запрос, который выполняется в базе "
"данных."

# 91052ed0d4524864805f7340fb7cc2f3
#: ../../ref/models/instances.txt:421
msgid ""
"**Emit a post-save signal.** The signal :attr:`django.db.models.signals."
"post_save` is sent, allowing any functions listening for that signal to take "
"some customized action."
msgstr ""
"**Посылается сигнал post-save.** Посылается сигнал :attr:`django.db.models."
"signals.post_save`, позволяя функциям, обрабатывающим этот сигнал, выполнить "
"какие-либо действия."

# 445b4fbfdf014f23bc065356b5f68677
#: ../../ref/models/instances.txt:427
msgid "How Django knows to UPDATE vs. INSERT"
msgstr "Как Django определят использовать UPDATE или INSERT"

# a692e205b6a04318ac7a2d019f0eacbb
#: ../../ref/models/instances.txt:429
msgid ""
"You may have noticed Django database objects use the same ``save()`` method "
"for creating and changing objects. Django abstracts the need to use "
"``INSERT`` or ``UPDATE`` SQL statements. Specifically, when you call "
"``save()``, Django follows this algorithm:"
msgstr ""
"Вы уже заметили что объекты модели используют метод ``save()`` как для "
"создания так и для изменения записи в базе данных. Django самостоятельно "
"определяет использовать ``INSERT`` или ``UPDATE``. При вызове ``save()``, "
"Django следует такому алгоритму:"

# b3dcce1ebf954ca482fd930b73e57efa
#: ../../ref/models/instances.txt:434
msgid ""
"If the object's primary key attribute is set to a value that evaluates to "
"``True`` (i.e., a value other than ``None`` or the empty string), Django "
"executes an ``UPDATE``."
msgstr ""
"Если атрибут первичного ключа объекта содержи значение равное ``True`` "
"(например, не ``None`` или не пустая строка), Django выполняет ``UPDATE`` "
"запрос."

# a13f1673a6524d59a3f2dd04dc251464
#: ../../ref/models/instances.txt:437
msgid ""
"If the object's primary key attribute is *not* set or if the ``UPDATE`` "
"didn't update anything, Django executes an ``INSERT``."
msgstr ""
"Если первичный ключ *не* указан, или ``UPDATE`` ничего не обновил, Django "
"выполнит ``INSERT``."

# 34aa17e5fafd43b08b28323d32cdadef
#: ../../ref/models/instances.txt:440
msgid ""
"The one gotcha here is that you should be careful not to specify a primary-"
"key value explicitly when saving new objects, if you cannot guarantee the "
"primary-key value is unused. For more on this nuance, see `Explicitly "
"specifying auto-primary-key values`_ above and `Forcing an INSERT or "
"UPDATE`_ below."
msgstr ""
"Будьте осторожны, явно указывая значение первичного ключа при сохранении "
"нового объекта, если вы не уверенны, что этот первичный ключ не "
"используется. Более подробно об этом читайте :ref:`Explicitly specifying "
"auto-primary-key values` (FIXME) и :ref:`ref-models-force-insert`."

# 71bee65874244f709b1210097335bc17
#: ../../ref/models/instances.txt:445
msgid ""
"In Django 1.5 and earlier, Django did a ``SELECT`` when the primary key "
"attribute was set. If the ``SELECT`` found a row, then Django did an "
"``UPDATE``, otherwise it did an ``INSERT``. The old algorithm results in one "
"more query in the ``UPDATE`` case. There are some rare cases where the "
"database doesn't report that a row was updated even if the database contains "
"a row for the object's primary key value. An example is the PostgreSQL ``ON "
"UPDATE`` trigger which returns ``NULL``. In such cases it is possible to "
"revert to the old algorithm by setting the :attr:`~django.db.models.Options."
"select_on_save` option to ``True``."
msgstr ""
"В предыдущих версиях Django выполнялся ``SELECT`` запрос, когда первичный "
"ключ был явно указан. Если ``SELECT`` находил строку, Django выполнял "
"``UPDATE`` запрос, иначе -- ``INSERT``. В результате выполнялся один лишний "
"запрос в случае использования ``UPDATE``. В очень редких случаях база данных "
"не оповещает об обновлении записи, если уже есть с указанным первичным "
"ключом. Например, тригер PostgreSQL ``ON UPDATE``, который возвращает "
"``NULL``. В таких случаях можно вернуться к старому алгоритму, указав "
"``True`` в :attr:`~django.db.models.Options.select_on_save`."

# d180ef568b2b4c21a0763872d5b1b3f8
#: ../../ref/models/instances.txt:458
msgid "Forcing an INSERT or UPDATE"
msgstr "Принудительное выполнение INSERT или UPDATE"

# 46e1acd5799248f49c7010a3adb1174a
#: ../../ref/models/instances.txt:460
msgid ""
"In some rare circumstances, it's necessary to be able to force the :meth:"
"`~Model.save()` method to perform an SQL ``INSERT`` and not fall back to "
"doing an ``UPDATE``. Or vice-versa: update, if possible, but not insert a "
"new row. In these cases you can pass the ``force_insert=True`` or "
"``force_update=True`` parameters to the :meth:`~Model.save()` method. "
"Obviously, passing both parameters is an error: you cannot both insert *and* "
"update at the same time!"
msgstr ""
"В редких случаях, может понадобиться принудительно заставить метод :meth:"
"`~Model.save()` выполнить ``INSERT`` запрос вместо ``UPDATE``. Или наоборот: "
"обновить, при возможности, но не добавлять новую запись. В этом случае вы "
"можете указать аргумент ``force_insert=True`` или ``force_update=True`` для "
"метода :meth:`~Model.save()`. Очевидно, не правильно использовать оба "
"аргумента вместе: вы не можете добавлять *и* обновлять одновременно!"

# 7aa800ee3a5d43b2a798e4d6993f27f8
#: ../../ref/models/instances.txt:468
msgid ""
"It should be very rare that you'll need to use these parameters. Django will "
"almost always do the right thing and trying to override that will lead to "
"errors that are difficult to track down. This feature is for advanced use "
"only."
msgstr ""
"Вряд ли вам понадобится использовать эти параметры. Django почти всегда "
"сделает то, что вам нужно, и переопределение такого поведения может привести "
"к ошибкам, которые трудно отследить. Эта функция предназначена для опытных "
"пользователей."

# 0cd8870db8004752b273f5fcb9f3c9dc
#: ../../ref/models/instances.txt:473
msgid ""
"Using ``update_fields`` will force an update similarly to ``force_update``."
msgstr ""
"Использование ``update_fields`` инициирует обновление объекта, как и при "
"вызове ``force_update``."

# 3e9e7e8e699741929140673d8bdd9a74
#: ../../ref/models/instances.txt:478
msgid "Updating attributes based on existing fields"
msgstr "Обновление значений полей"

# 5280780451ad4fb195240aac2eacc58b
#: ../../ref/models/instances.txt:480
msgid ""
"Sometimes you'll need to perform a simple arithmetic task on a field, such "
"as incrementing or decrementing the current value. The obvious way to "
"achieve this is to do something like::"
msgstr ""
"Иногда вам может понадобиться выполнить простые арифметические операции над "
"полями, такие как увеличить или уменьшить текущее значение. Очевидный способ "
"сделать это::"

# e928f345411d488ab159890fccc309c2
#: ../../ref/models/instances.txt:488
msgid ""
"If the old ``number_sold`` value retrieved from the database was 10, then "
"the value of 11 will be written back to the database."
msgstr ""
"Если старое значение ``number_sold``, полученное из базы данных, равно 10, в "
"базу данных будет записано значение 11."

# d4ecdc8b5c9d4726bce0631972668fa7
#: ../../ref/models/instances.txt:491
msgid ""
"The process can be made robust, :ref:`avoiding a race condition <avoiding-"
"race-conditions-using-f>`, as well as slightly faster by expressing the "
"update relative to the original field value, rather than as an explicit "
"assignment of a new value. Django provides :class:`F expressions <django.db."
"models.F>` for performing this kind of relative update. Using :class:`F "
"expressions <django.db.models.F>`, the previous example is expressed as::"
msgstr ""
"Этот процесс может быть надежным, :ref:`предотвращая состояния гонки "
"<avoiding-race-conditions-using-f>`, и немного быстрее, если выполнить "
"обновление значение поля, а не явное присвоение нового значения. Django "
"предоставляет :class:`объект F <django.db.models.F>` для выполнения "
"обновления. Используя :class:`F() <django.db.models.F>`, следующий пример "
"будет выглядеть таким образом::"

# 243276e7f53b4e898cafe9c475d44fa8
#: ../../ref/models/instances.txt:504
msgid ""
"For more details, see the documentation on :class:`F expressions <django.db."
"models.F>` and their :ref:`use in update queries <topics-db-queries-update>`."
msgstr ""
"Подробности смотрите в описании :class:`объекта F <django.db.models.F>` и "
"его :ref:`использование в запросах обновления <topics-db-queries-update>`."

# cf9cce4cc6d648e397d828700475686a
#: ../../ref/models/instances.txt:509
msgid "Specifying which fields to save"
msgstr "Указываем какие поля сохранять"

# d44d33036cd24ff7a4e8f6a13cc28a44
#: ../../ref/models/instances.txt:511
msgid ""
"If ``save()`` is passed a list of field names in keyword argument "
"``update_fields``, only the fields named in that list will be updated. This "
"may be desirable if you want to update just one or a few fields on an "
"object. There will be a slight performance benefit from preventing all of "
"the model fields from being updated in the database. For example::"
msgstr ""
"Если в ``save()`` передать именованный аргумент ``update_fields`` со списком "
"полей модели, только эти поля будут обновлены. Это может пригодиться, если "
"вы хотите обновить одно или несколько полей. Таким образом можно получить "
"небольшой прирост в производительности. Например::"

# 1a08e6b87af34a76ad19581af20ed6bc
#: ../../ref/models/instances.txt:520
msgid ""
"The ``update_fields`` argument can be any iterable containing strings. An "
"empty ``update_fields`` iterable will skip the save. A value of None will "
"perform an update on all fields."
msgstr ""
"``update_fields`` может принимать любой итератор строк. Пустой "
"``update_fields`` пропустит сохранение. None сохранит все поля."

# 543907df97154c85a0766942aee3fddb
#: ../../ref/models/instances.txt:524
msgid "Specifying ``update_fields`` will force an update."
msgstr "Указав ``update_fields`` вы инициируете редактирование записи."

# 2aeecc4ffc9b43f5868ae4fd5ae12425
#: ../../ref/models/instances.txt:526
msgid ""
"When saving a model fetched through deferred model loading (:meth:`~django."
"db.models.query.QuerySet.only()` or :meth:`~django.db.models.query.QuerySet."
"defer()`) only the fields loaded from the DB will get updated. In effect "
"there is an automatic ``update_fields`` in this case. If you assign or "
"change any deferred field value, the field will be added to the updated "
"fields."
msgstr ""
"Если модель была загружена не со всеми полями (через :meth:`~django.db."
"models.query.QuerySet.only()` или :meth:`~django.db.models.query.QuerySet."
"defer()`), только загруженные поля будут сохранены. В этом случае "
"``update_fields`` будет определен автоматически. Если значение поля будет "
"изменено, оно будет добавлено в список для обновления."

# 5710063c94b64f6a9867bbff8de57716
#: ../../ref/models/instances.txt:534
msgid "Deleting objects"
msgstr "Удаление объектов"

# e7946ed560a34e83b2c99a904e4407cf
#: ../../ref/models/instances.txt:538
msgid ""
"Issues an SQL ``DELETE`` for the object. This only deletes the object in the "
"database; the Python instance will still exist and will still have data in "
"its fields."
msgstr ""
"Выполняет SQL ``DELETE`` запрос для объекта. Удаляет объекты только из базы "
"данных; объекты Python будут существовать и содержать данные."

# 76bbf5d60a17460c98f0e01eaa8ecc3a
#: ../../ref/models/instances.txt:542
msgid ""
"For more details, including how to delete objects in bulk, see :ref:`topics-"
"db-queries-delete`."
msgstr ""
"Подробности, включая как удалить множество объектов, смотрите в :ref:`topics-"
"db-queries-delete`."

# 15b756b0ac7d48188d9957ab58daff95
#: ../../ref/models/instances.txt:545
msgid ""
"If you want customized deletion behavior, you can override the ``delete()`` "
"method. See :ref:`overriding-model-methods` for more details."
msgstr ""
"Если вам нужно изменить процесс удаления, переопределите метод ``delete()``. "
"Подробности в :ref:`overriding-model-methods`."

# 5710063c94b64f6a9867bbff8de57716
#: ../../ref/models/instances.txt:549
msgid "Pickling objects"
msgstr "Сериализация объектов"

#: ../../ref/models/instances.txt:551
msgid ""
"When you :mod:`pickle` a model, its current state is pickled. When you "
"unpickle it, it'll contain the model instance at the moment it was pickled, "
"rather than the data that's currently in the database."
msgstr ""
"При упаковке объекта модели с помощью :mod:`pickle` сохраняется текущее "
"состояние. При распаковке объекта он содержит объект модели в состоянии на "
"момент упаковки, а не текущее состояние в базе данных."

#: ../../ref/models/instances.txt:555
msgid "You can't share pickles between versions"
msgstr ""
"Вы не можете использовать объекты, упакованные на разных версиях Django"

#: ../../ref/models/instances.txt:557
msgid ""
"Pickles of models are only valid for the version of Django that was used to "
"generate them. If you generate a pickle using Django version N, there is no "
"guarantee that pickle will be readable with Django version N+1. Pickles "
"should not be used as part of a long-term archival strategy."
msgstr ""
"Упакованные модели работают только для той версии Django, на которой они "
"были созданы. Если вы упаковали модель на Django версии N, нет гарантии, что "
"вы сомжете распаковать её на Django версии N+1. Упаковка моделей не должна "
"использоваться для долговременного архивирования объектов."

#: ../../ref/models/instances.txt:565
msgid ""
"Since pickle compatibility errors can be difficult to diagnose, such as "
"silently corrupted objects, a ``RuntimeWarning`` is raised when you try to "
"unpickle a model in a Django version that is different than the one in which "
"it was pickled."
msgstr ""
"Ошибки несовместимости версий при распаковке объектом тяжело "
"диагностировать, например сломанный объект, поэтому вызывается "
"``RuntimeWarning`` при попытке распаковать модель на версии Django отличной "
"от той, которая использовалась при упаковке."

# 722e6dd3564f4c2a821c76ed276b03c9
#: ../../ref/models/instances.txt:573
msgid "Other model instance methods"
msgstr "Остальные методы модели"

# b485a9afc82343eeab9befa8696e54ac
#: ../../ref/models/instances.txt:575
msgid "A few object methods have special purposes."
msgstr "Несколько методов имеют специальное назначение."

# 7c4746597e1a4bf5bb9efe94d1b82ec0
#: ../../ref/models/instances.txt:578
msgid ""
"On Python 3, as all strings are natively considered Unicode, only use the "
"``__str__()`` method (the ``__unicode__()`` method is obsolete). If you'd "
"like compatibility with Python 2, you can decorate your model class with :"
"func:`~django.utils.encoding.python_2_unicode_compatible`."
msgstr ""
"В Python 3, так как все строки являются Unicode строками, используйте только "
"метод ``__str__()`` (метод ``__unicode__()`` устарел). Если вам необходима "
"совместимость с Python 2, Можете декорировать ваш класс модели декоратором :"
"func:`~django.utils.encoding.python_2_unicode_compatible`."

# 77ddec81cdd4478dac1e8dcf53721767
#: ../../ref/models/instances.txt:584
msgid "``__unicode__``"
msgstr "``__unicode__``"

# 322fead3b40a4c5780afc817e7714563
#: ../../ref/models/instances.txt:588
msgid ""
"The ``__unicode__()`` method is called whenever you call ``unicode()`` on an "
"object. Django uses ``unicode(obj)`` (or the related function, :meth:"
"`str(obj) <Model.__str__>`) in a number of places. Most notably, to display "
"an object in the Django admin site and as the value inserted into a template "
"when it displays an object. Thus, you should always return a nice, human-"
"readable representation of the model from the ``__unicode__()`` method."
msgstr ""
"Метод ``__unicode__()`` вызывается когда вы применяете функцию ``unicode()`` "
"к объекту. Django использует ``unicode(obj)`` (или похожую функцию :meth:"
"`str(obj) <Model.__str__>`) вы нескольких местах. В частности, для "
"отображения объектов в интерфейсе администратора Django и в качестве "
"значения, вставляемого в шаблон, при отображении объекта. Поэтому, вы должны "
"всегда возвращать в методе ``__unicode__()`` красивое и удобное для "
"восприятия представление объекта."

# 5b4e92636d0f4db499d2704f36b4edfb
# f0f49d96bd0242a4bb39fa7a3a784269
#: ../../ref/models/instances.txt:595 ../../ref/models/instances.txt:625
#: ../../ref/models/instances.txt:667 ../../ref/models/instances.txt:719
#: ../../ref/models/instances.txt:728 ../../ref/models/instances.txt:799
msgid "For example::"
msgstr "Например::"

# 77610f5d55554d99963e837d02254090
#: ../../ref/models/instances.txt:606
msgid ""
"If you define a ``__unicode__()`` method on your model and not a :meth:"
"`~Model.__str__()` method, Django will automatically provide you with a :"
"meth:`~Model.__str__()` that calls ``__unicode__()`` and then converts the "
"result correctly to a UTF-8 encoded string object. This is recommended "
"development practice: define only ``__unicode__()`` and let Django take care "
"of the conversion to string objects when required."
msgstr ""
"Если вы определили метод ``__unicode__()`` и не определили :meth:`~Model."
"__str__()`, Django самостоятельно добавит метод :meth:`~Model.__str__()` "
"который вызывает ``__unicode__()``, затем преобразует результат в строку в "
"кодировке UTF-8. Это рекомендуемый подход: определить только "
"``__unicode__()`` и позволить Django самостоятельно преобразовать в строку "
"при необходимости."

# 811e6bcf2367418bb7cdc15a31029b32
#: ../../ref/models/instances.txt:614
msgid "``__str__``"
msgstr "``__str__``"

# 322fead3b40a4c5780afc817e7714563
#: ../../ref/models/instances.txt:618
msgid ""
"The ``__str__()`` method is called whenever you call ``str()`` on an object. "
"In Python 3, Django uses ``str(obj)`` in a number of places. Most notably, "
"to display an object in the Django admin site and as the value inserted into "
"a template when it displays an object. Thus, you should always return a "
"nice, human-readable representation of the model from the ``__str__()`` "
"method."
msgstr ""
"Метод ``__str__()`` вызывается когда вы применяете функцию ``str()`` к "
"объекту. В Python 3 Django использует ``str(obj)`` в нескольких местах. В "
"частности, для отображения объектов в интерфейсе администратора Django и в "
"качестве значения, вставляемого в шаблон, при отображении объекта. Поэтому, "
"вы должны всегда возвращать в методе ``__str__()`` красивое и удобное для "
"восприятия представление объекта."

# c1169ef193684b02a2f0ff7ea349c3bd
#: ../../ref/models/instances.txt:636
msgid ""
"In Python 2, the main use of ``__str__`` directly inside Django is when the "
"``repr()`` output of a model is displayed anywhere (for example, in "
"debugging output). It isn't required to put ``__str__()`` methods everywhere "
"if you have sensible :meth:`~Model.__unicode__()` methods."
msgstr ""
"В Python 2 Django использует ``__str__``, если нужно вывести результат "
"функции ``repr()`` (например, при отладке). Определять метод ``__str__()`` "
"не обязательно, если вы определили метод :meth:`~Model.__unicode__()`."

# 389315b6074e4b5ebd98d75cde5e3c31
#: ../../ref/models/instances.txt:642
msgid ""
"The previous :meth:`~Model.__unicode__()` example could be similarly written "
"using ``__str__()`` like this::"
msgstr ""
"Предыдущий пример метода :meth:`~Model.__unicode__()` может аналогично "
"использоваться и в ``__str__()``::"

# 811e6bcf2367418bb7cdc15a31029b32
#: ../../ref/models/instances.txt:658
msgid "``__eq__``"
msgstr "``__eq__``"

# 7432bc1b5e2b44afbd28a4849049e0c9
#: ../../ref/models/instances.txt:662
msgid ""
"The equality method is defined such that instances with the same primary key "
"value and the same concrete class are considered equal. For proxy models, "
"concrete class is defined as the model's first non-proxy parent; for all "
"other models it is simply the model's class."
msgstr ""
"Метод проверки равенства по умолчанию работает следующим образом: если два "
"объекта содержат одинаковый первичный ключ и являются экземплярами одно "
"класса, тогда они равны. Для прокси-моделей класс определяется поиском "
"первого не прокси родительского класса. Для всех остальных моделей - это "
"просто класс модели."

# 7fba26715f1e4b7c8ac7a636306b435c
#: ../../ref/models/instances.txt:688
msgid ""
"In previous versions only instances of the exact same class and same primary "
"key value were considered equal."
msgstr ""
"В предыдущих версиях только экземпляры одно класса с одинаковым первичным "
"ключом считались равными."

# 811e6bcf2367418bb7cdc15a31029b32
#: ../../ref/models/instances.txt:692
msgid "``__hash__``"
msgstr "``__hash__``"

# a0325aa2b4d24f9faef17863e297b50e
#: ../../ref/models/instances.txt:696
msgid ""
"The ``__hash__`` method is based on the instance's primary key value. It is "
"effectively hash(obj.pk). If the instance doesn't have a primary key value "
"then a ``TypeError`` will be raised (otherwise the ``__hash__`` method would "
"return different values before and after the instance is saved, but changing "
"the ``__hash__`` value of an instance `is forbidden in Python`_)."
msgstr ""
"Метод ``__hash__`` использует значение первичного ключа. На самом деле "
"выполняется ``hash(obj.pk)``. Если первичный ключ не определен, будет "
"вызвано исключение ``TypeError`` (иначе ``__hash__`` разные значения перед и "
"после сохранения объекта, что `запрещено в Python <https://docs.python.org/2/"
"reference/datamodel.html#object.__hash__>`_)."

# e9b3eb5672fd40509235cd750229c4c2
#: ../../ref/models/instances.txt:705
msgid ""
"In previous versions instance's without primary key value were hashable."
msgstr ""
"В предыдущих версиях объекты без первичного ключа можно было хешировать."

# 7be347663638442f8bf2f6a99674af1d
#: ../../ref/models/instances.txt:711
msgid "``get_absolute_url``"
msgstr "``get_absolute_url``"

# 170be423e7b9487797847057de6377f5
#: ../../ref/models/instances.txt:715
msgid ""
"Define a ``get_absolute_url()`` method to tell Django how to calculate the "
"canonical URL for an object. To callers, this method should appear to return "
"a string that can be used to refer to the object over HTTP."
msgstr ""
"Определите метод ``get_absolute_url()``, чтобы указать Django как вычислить "
"URL для объекта. Метод должен вернуть строку, которая может быть "
"использована в HTTP запросе."

# c2e13c9d8417413bac11402b7b71ad6d
#: ../../ref/models/instances.txt:724
msgid ""
"(Whilst this code is correct and simple, it may not be the most portable way "
"to write this kind of method. The :func:`~django.core.urlresolvers.reverse` "
"function is usually the best approach.)"
msgstr ""
"(Хотя это код правильный и простой, но такой подход не самый лучший для "
"создания подобных методов. Лучше использовать функцию :func:`~django.core."
"urlresolvers.reverse`.)"

# f01a31faf0bc4c679cb0db2cfa8b3b01
#: ../../ref/models/instances.txt:734
msgid ""
"One place Django uses ``get_absolute_url()`` is in the admin app. If an "
"object defines this method, the object-editing page will have a \"View on "
"site\" link that will jump you directly to the object's public view, as "
"given by ``get_absolute_url()``."
msgstr ""
"Django использует ``get_absolute_url()`` в интерфейсе администратора. Если "
"объект содержит этот метод, страница редактирования объекта будет содержать "
"ссылку \"Показать на сайте\", которая приведет к странице отображения "
"объекта, ссылку на которую возвращает ``get_absolute_url()``."

# f16957c12a9b4c5184b86620d3f85233
#: ../../ref/models/instances.txt:739
msgid ""
"Similarly, a couple of other bits of Django, such as the :doc:`syndication "
"feed framework </ref/contrib/syndication>`, use ``get_absolute_url()`` when "
"it is defined. If it makes sense for your model's instances to each have a "
"unique URL, you should define ``get_absolute_url()``."
msgstr ""
"Кроме того, несколько приложений Django также используют этот метод, "
"например :doc:`syndication feed framework </ref/contrib/syndication>`. Если "
"объект модели представляет какой-то уникальный URL, вам стоит определить "
"метод ``get_absolute_url()``."

#: ../../ref/models/instances.txt:746
msgid ""
"You should avoid building the URL from unvalidated user input, in order to "
"reduce possibilities of link or redirect poisoning::"
msgstr ""
"При создания URL не используйте непроверенные данные от пользователя, чтобы "
"избежать подделки ссылок или перенаправлений::"

#: ../../ref/models/instances.txt:752
msgid ""
"If ``self.name`` is ``'/example.com'`` this returns ``'//example.com/'`` "
"which, in turn, is a valid schema relative URL but not the expected ``'/"
"%2Fexample.com/'``."
msgstr ""
"Если ``self.name`` равен ``'/example.com'``, будет возвращен ``'//example."
"com/'``, являющимся правильным URL-ом относительно протокола, вместо "
"ожидаемого ``'/%2Fexample.com/'``."

# c79820e1a3f049c6b2afbf034475175e
#: ../../ref/models/instances.txt:757
msgid ""
"It's good practice to use ``get_absolute_url()`` in templates, instead of "
"hard-coding your objects' URLs. For example, this template code is bad:"
msgstr ""
"Хорошая практика использовать ``get_absolute_url()`` в шаблонах, вместо "
"того, чтобы \"хардкодить\" URL-ы. Например, это плохой подход:"

# 366627a9ab644c97b9436cbfe11008c1
#: ../../ref/models/instances.txt:765
msgid "This template code is much better:"
msgstr "Этот шаблон значительно лучше:"

# f6ba7b82b1be4413bd17195594598517
#: ../../ref/models/instances.txt:771
msgid ""
"The logic here is that if you change the URL structure of your objects, even "
"for something simple such as correcting a spelling error, you don't want to "
"have to track down every place that the URL might be created. Specify it "
"once, in ``get_absolute_url()`` and have all your other code call that one "
"place."
msgstr ""
"Идея в том что, если вы измените структуру URL-а для объекта, или просто "
"исправите опечатку, вам не нужно исправлять его во всех местах, где этот URL "
"используется. Просто определите его один раз в методе "
"``get_absolute_url()``, и пусть остальной код использует его."

# 2b5c045aaa9a42faa0fac63212011858
#: ../../ref/models/instances.txt:777
msgid ""
"The string you return from ``get_absolute_url()`` **must** contain only "
"ASCII characters (required by the URI specification, :rfc:`2396`) and be URL-"
"encoded, if necessary."
msgstr ""
"Строка, которую возвращает ``get_absolute_url()``, **должна** состоять "
"только из ASCII символов (требуется спецификацией URI, :rfc:`2396`) и быть "
"закодированной для URL, если необходимо."

# a2803a2645ed46faa1d84776eab4976a
#: ../../ref/models/instances.txt:781
msgid ""
"Code and templates calling ``get_absolute_url()`` should be able to use the "
"result directly without any further processing. You may wish to use the "
"``django.utils.encoding.iri_to_uri()`` function to help with this if you are "
"using unicode strings containing characters outside the ASCII range at all."
msgstr ""
"Код и шаблоны, использующие ``get_absolute_url()``, должны иметь возможность "
"использовать результат без обработки. Вы можете использовать функцию "
"``django.utils.encoding.iri_to_uri()``, если используете unicode-строку, "
"которая содержит не ASCII символы."

# 453c15c6a8844c309a23b08f28369113
#: ../../ref/models/instances.txt:788
msgid "Extra instance methods"
msgstr "Дополнительные методы модели"

# cf5de768199043bc8999fe4610b43407
#: ../../ref/models/instances.txt:790
msgid ""
"In addition to :meth:`~Model.save()`, :meth:`~Model.delete()`, a model "
"object might have some of the following methods:"
msgstr ""
"В дополнение к методам :meth:`~Model.save()`, :meth:`~Model.delete()`, "
"объект модели может содержать некоторые из этих методов:"

# e0af5f91ae4a45bfa89adb4e84adaa04
#: ../../ref/models/instances.txt:795
msgid ""
"For every field that has :attr:`~django.db.models.Field.choices` set, the "
"object will have a ``get_FOO_display()`` method, where ``FOO`` is the name "
"of the field. This method returns the \"human-readable\" value of the field."
msgstr ""
"Для каждого поля, которое содержит :attr:`~django.db.models.Field.choices`, "
"объект будет иметь метод ``get_FOO_display()``, где ``FOO`` имя поля. Этот "
"метод возвращает удобное для восприятия название для значения поля."

# 29b4c3a7c4604d31883039917f636f41
#: ../../ref/models/instances.txt:824
msgid ""
"For every :class:`~django.db.models.DateField` and :class:`~django.db.models."
"DateTimeField` that does not have :attr:`null=True <django.db.models.Field."
"null>`, the object will have ``get_next_by_FOO()`` and "
"``get_previous_by_FOO()`` methods, where ``FOO`` is the name of the field. "
"This returns the next and previous object with respect to the date field, "
"raising a :exc:`~django.core.exceptions.DoesNotExist` exception when "
"appropriate."
msgstr ""
"Для каждого поля :class:`~django.db.models.DateField` и :class:`~django.db."
"models.DateTimeField`, которое не содержит :attr:`null=True <django.db."
"models.Field.null>`, объект будет иметь методы ``get_next_by_FOO()`` и "
"``get_previous_by_FOO()``, где ``FOO`` название поля. Они возвращают "
"следующий и предыдущий объект в соответствии со значением этого поля, "
"вызывая соответствующее исключение :exc:`~django.db.DoesNotExist`, если "
"объект не существует."

# 23fa6b7de97c48abac35b6b507368d0b
#: ../../ref/models/instances.txt:831
msgid ""
"Both of these methods will perform their queries using the default manager "
"for the model. If you need to emulate filtering used by a custom manager, or "
"want to perform one-off custom filtering, both methods also accept optional "
"keyword arguments, which should be in the format described in :ref:`Field "
"lookups <field-lookups>`."
msgstr ""
"Оба метода используют менеджер по умолчанию модели. Если вам необходимо "
"использовать свой менеджер, которые должен выполнить какую-то фильтрацию, "
"или просто добавить дополнительную фильтрацию, в методы можно передать "
"дополнительные аргументы, которые должны соответствовать формату  :ref:"
"`операторов фильтрации <field-lookups>`."

# ee2b2e31cf7b488799a7efffc60e78a9
#: ../../ref/models/instances.txt:837
msgid ""
"Note that in the case of identical date values, these methods will use the "
"primary key as a tie-breaker. This guarantees that no records are skipped or "
"duplicated. That also means you cannot use those methods on unsaved objects."
msgstr ""
"Заметим, что в случае одинаковых значений даты, эти методы будут "
"использовать значение первичного ключа, для определения порядка объектов. "
"Это гарантирует, что записи не будут пропущены или дублированы. Это также "
"означает, что вы не можете использовать эти методы для не сохраненных "
"объектов."

# 37762212f32a43b9833eafa10a1f02f6
#~ msgid ""
#~ "The ``validate_unique`` parameter was added to allow skipping :meth:"
#~ "`Model.validate_unique()`. Previously, :meth:`Model.validate_unique()` "
#~ "was always called by ``full_clean``."
#~ msgstr ""
#~ "Параметр ``validate_unique`` был добавлен для пропуска проверки :meth:"
#~ "`Model.validate_unique()`. Ранее :meth:`Model.validate_unique()` "
#~ "вызывался всегда при вызове ``full_clean``."

# 2543e14c1a644a1e8e41151dbeeab8ab
#~ msgid "The ``permalink`` decorator"
#~ msgstr "Декоратор ``permalink``"

# a0a6eae7bb9d4ef7a81fa0512c5fede1
#~ msgid ""
#~ "The ``permalink`` decorator is no longer recommended. You should use :"
#~ "func:`~django.core.urlresolvers.reverse` in the body of your "
#~ "``get_absolute_url`` method instead."
#~ msgstr ""
#~ "Декоратор ``permalink`` больше не рекомендуется. Следует использовать :"
#~ "func:`~django.core.urlresolvers.reverse` в методе ``get_absolute_url``."

# 0f2a9906c5454e6f8e5d462596a1630d
#~ msgid ""
#~ "In early versions of Django, there wasn't an easy way to use URLs defined "
#~ "in URLconf file inside :meth:`~django.db.models.Model.get_absolute_url`. "
#~ "That meant you would need to define the URL both in URLConf and :meth:"
#~ "`~django.db.models.Model.get_absolute_url`. The ``permalink`` decorator "
#~ "was added to overcome this DRY principle violation. However, since the "
#~ "introduction of :func:`~django.core.urlresolvers.reverse` there is no "
#~ "reason to use ``permalink`` any more."
#~ msgstr ""
#~ "В ранних версиях Django не было просто способа использовать URL "
#~ "определенный в URLconf в методе :meth:`~django.db.models.Model."
#~ "get_absolute_url`. Вам приходилось определять URL и в URLConf и в :meth:"
#~ "`~django.db.models.Model.get_absolute_url`. Для соблюдения DRY принципа "
#~ "был добавлен декоратор ``permalink``. Но после представления функции :"
#~ "func:`~django.core.urlresolvers.reverse` отпала надобность в "
#~ "``permalink``."

# 0de89d47f43f44d49c394757dba7a1cb
#~ msgid ""
#~ "This decorator takes the name of a URL pattern (either a view name or a "
#~ "URL pattern name) and a list of position or keyword arguments and uses "
#~ "the URLconf patterns to construct the correct, full URL. It returns a "
#~ "string for the correct URL, with all parameters substituted in the "
#~ "correct positions."
#~ msgstr ""
#~ "Этот декоратор принимает названия шаблона URL (либо имя представления, "
#~ "либо название шаблона URL) и список позиционных или именованных "
#~ "аргументов шаблона URLconf для вычисления правильного и полного URL. Он "
#~ "возвращает правильный URL, с учетом всех аргументов."

# daa122604922490fb98638f694970b68
#~ msgid ""
#~ "The ``permalink`` decorator is a Python-level equivalent to the :ttag:"
#~ "`url` template tag and a high-level wrapper for the :func:`~django.core."
#~ "urlresolvers.reverse` function."
#~ msgstr ""
#~ "Декоратор ``permalink`` это эквивалент шаблонного тега :ttag:`url` и "
#~ "обертка для функции :func:`~django.core.urlresolvers.reverse`."

# 1655bcda94964ca3bf1dbeae206f18d7
#~ msgid ""
#~ "An example should make it clear how to use ``permalink()``. Suppose your "
#~ "URLconf contains a line such as::"
#~ msgstr ""
#~ "Пример покажет как использовать ``permalink()``. Предположим у на есть "
#~ "такой URLconf::"

# b7b893018cd1456b8026524b479956c1
#~ msgid ""
#~ "...your model could have a :meth:`~django.db.models.Model."
#~ "get_absolute_url` method that looked like this::"
#~ msgstr ""
#~ "...ваша модель может определить метод :meth:`~django.db.models.Model."
#~ "get_absolute_url` таким образом::"

# 802da1e481af4c5082ad2fed6faeaae9
#~ msgid "Similarly, if you had a URLconf entry that looked like::"
#~ msgstr "Добавим еще одну строку в URLconf::"

# f6bc301e2a664f01ad133cd4048eb2db
#~ msgid "...you could reference this using ``permalink()`` as follows::"
#~ msgstr "...теперь ``permalink()`` можно использовать таким образом::"

# 12d9d11a392c4ece98b445b7838fcf84
#~ msgid ""
#~ "Notice that we specify an empty sequence for the second parameter in this "
#~ "case, because we only want to pass keyword parameters, not positional "
#~ "ones."
#~ msgstr ""
#~ "Обратите внимание, мы указали пустую последовательность вторым "
#~ "параметром, потому что хотим использовать только именованные аргументы."

# 316dfa73947d483685e17f74efb6264d
#~ msgid ""
#~ "In this way, you're associating the model's absolute path with the view "
#~ "that is used to display it, without repeating the view's URL information "
#~ "anywhere. You can still use the :meth:`~django.db.models.Model."
#~ "get_absolute_url()` method in templates, as before."
#~ msgstr ""
#~ "Таким образом, мы связали абсолютный путь модели с представлением, "
#~ "которое отображает ее, без повторного упоминания информации про URL. Вы "
#~ "можете использовать метод :meth:`~django.db.models.Model."
#~ "get_absolute_url()` в шаблоне, как было показано выше."

# 57204706e08e4e6ca39b05f42d2dea98
#~ msgid ""
#~ "In some cases, such as the use of generic views or the re-use of custom "
#~ "views for multiple models, specifying the view function may confuse the "
#~ "reverse URL matcher (because multiple patterns point to the same view). "
#~ "For that case, Django has :ref:`named URL patterns <naming-url-"
#~ "patterns>`. Using a named URL pattern, it's possible to give a name to a "
#~ "pattern, and then reference the name rather than the view function. A "
#~ "named URL pattern is defined by replacing the pattern tuple by a call to "
#~ "the ``url`` function)::"
#~ msgstr ""
#~ "В некоторых случаях, таких, как использование общих представлений или "
#~ "повторное использование представления для нескольких моделей, "
#~ "использование представления может обескуражить определение URL (так как "
#~ "несколько шаблонов используют одно представление). Для таких случаев, "
#~ "Django имеет :ref:`именованные шаблоны URL <naming-url-patterns>`. При их "
#~ "использовании, можно добавить название для шаблона URL, и использовать "
#~ "его вместо функции представления при определении URL, именованные шаблоны "
#~ "URL определяются заменой кортежа в URLconf на вызов функции ``url``)::"

# ee9251dfedba4df1bee846838c55e640
#~ msgid ""
#~ "...and then using that name to perform the reverse URL resolution instead "
#~ "of the view name::"
#~ msgstr ""
#~ "...а затем использовать это название вместо названия функции "
#~ "представления для вычисления URL::"

# cfc54b578d704da8b1de4d5c5351a237
#~ msgid ""
#~ "More details on named URL patterns are in the :doc:`URL dispatch "
#~ "documentation </topics/http/urls>`."
#~ msgstr ""
#~ "Подробности вы можете узнать в разделе о :doc:`менеджере URL </topics/"
#~ "http/urls>`."

# f558936c4c5a4cce8a4a5ed14bd6f9dc
#~ msgid ""
#~ "This sequence has a standard update problem in that it contains a race "
#~ "condition. If another thread of execution has already saved an updated "
#~ "value after the current thread retrieved the old value, the current "
#~ "thread will only save the old value plus one, rather than the new "
#~ "(current) value plus one."
#~ msgstr ""
#~ "Этот код отображает распространенную проблему \"гонки\". Если другой "
#~ "поток сохранил обновленное значение после того, как текущий поток "
#~ "прочитал старое значение, текущий поток сохранит просто старое значение "
#~ "плюс один, а не новое(текущее) значение плюс один."

# b8bcd00048d949af8374c8169c90d582
#~ msgid ""
#~ "This approach doesn't use the initial value from the database. Instead, "
#~ "it makes the database do the update based on whatever value is current at "
#~ "the time that the :meth:`~Model.save()` is executed."
#~ msgstr ""
#~ "Такой подход не использует начальное значение из базы данных. Вместо "
#~ "этого, база данных выполнит обновление текущего значения при вызове "
#~ "метода :meth:`~Model.save()`."

# 0a6dd6bd5ca042abad21f7a3d651f1ba
#~ msgid ""
#~ "Once the object has been saved, you must reload the object in order to "
#~ "access the actual value that was applied to the updated field::"
#~ msgstr ""
#~ "Как только объект был сохранен, необходимо перезагрузить объект для "
#~ "доступа к значению, которое было установлено при обновлении поля::"

# 1a6a7d81bc384d96aad756aad0f488ca
#~ msgid ""
#~ "Note that ``full_clean()`` will *not* be called automatically when you "
#~ "call your model's :meth:`~Model.save()` method, nor as a result of :class:"
#~ "`~django.forms.ModelForm` validation. In the case of :class:`~django."
#~ "forms.ModelForm` validation, :meth:`Model.clean_fields()`, :meth:`Model."
#~ "clean()`, and :meth:`Model.validate_unique()` are all called individually."
#~ msgstr ""
#~ "Заметим, ``full_clean()`` *не* вызывается ни при вызове метода :meth:"
#~ "`~Model.save()` модели, ни в результате проверки в :class:`~django.forms."
#~ "ModelForm`. В этом случае вызывается :class:`~django.forms.ModelForm` "
#~ "validation, :meth:`Model.clean_fields()`, :meth:`Model.clean()` и :meth:"
#~ "`Model.validate_unique()`."

# bed72b10d96343c4b711127d99134753
#~ msgid ""
#~ "If the record with the given primary key does already exist, Django "
#~ "executes an ``UPDATE`` query."
#~ msgstr ""
#~ "Если запись с указанным первичным ключом уже существует, Django выполняет "
#~ "``UPDATE`` запрос."
